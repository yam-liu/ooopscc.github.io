<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on 一言半辞</title><link>http://localhost:1313/posts/</link><description>Recent content in Posts on 一言半辞</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sun, 17 Apr 2022 20:12:00 +0800</lastBuildDate><atom:link href="http://localhost:1313/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>How `Cedar` implement this syntax without punctuation?</title><link>http://localhost:1313/posts/cedar-syntax-investigate/</link><pubDate>Sun, 17 Apr 2022 20:12:00 +0800</pubDate><guid>http://localhost:1313/posts/cedar-syntax-investigate/</guid><description>&lt;p>A few days ago, I searched for a Unit Test framework for Objc&amp;amp;Swift. Occasionally, I found &lt;code>Cedar&lt;/code>. I know that all UT frameworks are much the same, but &lt;code>Cedar&lt;/code>&amp;rsquo;s syntax attracted me.&lt;/p>
&lt;p>The sample code is like below.&lt;/p></description></item><item><title>删除某条 Chrome 自动补全的网址记录</title><link>http://localhost:1313/posts/delete-chrome-completion-record/</link><pubDate>Wed, 21 Dec 2016 19:53:39 +0800</pubDate><guid>http://localhost:1313/posts/delete-chrome-completion-record/</guid><description>Chrome有一个很好又不太好的功能，就是omnibar上的自动补全网址。 经常使用Chrome的人可能会遇到这样一个情形：Chrome给补全的网址不是我们期望的，往往在下面的位置。比如下面这样： 我提了</description></item><item><title>下载老版本 iOS SDK 开发文档</title><link>http://localhost:1313/posts/download-old-ios-documentation/</link><pubDate>Wed, 21 Dec 2016 19:52:12 +0800</pubDate><guid>http://localhost:1313/posts/download-old-ios-documentation/</guid><description>众所周知，苹果是一个“极度激进”的公司，发布iOS10，就想让你放弃iOS9。可国内的现状是想摆脱iOS8都困难，不支持iOS7都会是一个很艰难的决定。同时，升级Xcode会把旧版本的开发文档移除，开</description></item><item><title>Run, Run Loop, Run!</title><link>http://localhost:1313/posts/run-runloop-run/</link><pubDate>Fri, 09 Sep 2016 19:37:36 +0800</pubDate><guid>http://localhost:1313/posts/run-runloop-run/</guid><description>&lt;blockquote>
&lt;p>&lt;em>翻译自 &lt;a href="http://bou.io/RunRunLoopRun.html">http://bou.io/RunRunLoopRun.html&lt;/a>&lt;/em>&lt;/p>
&lt;/blockquote>
&lt;p>尽管作为所有App最重要的组成部分之一，它仍是一个开发者很少被触及讨论的话题：Run Loop。Run Loop之于app的就像是跳动的心脏，他们是使你app运行的真正奥义。&lt;/p>
&lt;p>事实上，一个run loop（运行循环）最基本的原则非常简单。在iOS和OS X&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>，&lt;code>CFRunLoop&lt;/code>实现被更高层级发送和分发消息API使用的核心机制。&lt;/p>
&lt;h1 id="所以run-loop到底是什么">所以，Run Loop到底是什么？&lt;/h1></description></item><item><title>CocoaPods 1.0 迁移指南</title><link>http://localhost:1313/posts/cocoapods-1.0-migration-guide/</link><pubDate>Fri, 05 Aug 2016 19:43:28 +0800</pubDate><guid>http://localhost:1313/posts/cocoapods-1.0-migration-guide/</guid><description>TL;DR 必须定义targets，之前未定义的话会默认使用第一个target 定义的target必须表示一个Xcode target 如果需要表示用在多个target中一系列pods的集合，可以使用abstract_pods</description></item><item><title>replay, replayLast 和 replayLazily 的区别</title><link>http://localhost:1313/posts/replay-replaylast-replaylazily/</link><pubDate>Sun, 03 Jul 2016 19:41:26 +0800</pubDate><guid>http://localhost:1313/posts/replay-replaylast-replaylazily/</guid><description>&lt;blockquote>
&lt;p>&lt;em>翻译自 &lt;a href="https://spin.atomicobject.com/author/bacon/">Patrick Bacon&lt;/a>的&lt;a href="https://spin.atomicobject.com/2014/06/29/replay-replaylast-replaylazily/">Comparing replay, replayLast, and replayLazily&lt;/a>&lt;/em>&lt;/p>
&lt;/blockquote>
&lt;p>一位同事最近问我关于 ReactiveCocoa 中&lt;code>replay&lt;/code>,&lt;code>replayLast&lt;/code>和&lt;code>replayLazily&lt;/code>的区别，才发现我只是对它们有一个模糊的理解，并不能把它们的区别解释的很清楚，所以我认为我应该深入了解一下。&lt;/p>
&lt;p>你会发现，如果对&lt;code>RACReplaySubject&lt;/code>和&lt;code>RACMulticastConnection&lt;/code>没有一个很好的理解的话，只看头文件中的注释还是很难看懂，所以我试图在不涉及的底层概念的情况下解释一下这几个replay方法。&lt;/p></description></item></channel></rss>