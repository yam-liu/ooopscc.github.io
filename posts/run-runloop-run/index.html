<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Davel"><title>Run, Run Loop, Run! ｜ 一言半辞</title><meta name=description content=" 翻译自 http://bou.io/RunRunLoopRun.html
 尽管作为所有App最重要的组成部分之一，它仍是一个开发者很少被触及讨论的话题：Run Loop。Run Loop之于app的就像是跳动的心脏，他们是使你app运行的真正奥义。
事实上，一个run loop（运行循环）最基本的原则非常简单。在iOS和OS X1，CFRunLoop实现被更高层级发送和分发消息API使用的核心机制。
所以，Run Loop到底是什么？"><meta name=keywords content="Hugo,theme,zozo"><link rel="shortcut icon" href=http://localhost:1313/images/favicon.ico><link rel=stylesheet type=text/css media=screen href=http://localhost:1313/css/normalize.css><link rel=stylesheet type=text/css media=screen href=https://cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css><link rel=stylesheet type=text/css media=screen href=http://localhost:1313/css/zozo.css><link rel=stylesheet type=text/css media=screen href=https://cdn.jsdelivr.net/npm/remixicon@2.5.0/fonts/remixicon.css><link rel=stylesheet type=text/css media=screen href=http://localhost:1313/css/highlight.css></head><body><div class="main animate__animated animate__fadeInDown"><div class="nav_container animated fadeInDown"><div class=site_nav id=site_nav><ul><li><a href=/>Home</a></li><li><a href=/posts/>Archive</a></li><li><a href=/tags/>Tags</a></li></ul></div><div class=menu_icon><a id=menu_icon><i class=ri-menu-line></i></a></div></div><div class="header animated fadeInDown"><div class=site_title_container><div class=site_title><h1><a href=http://localhost:1313/><span>一言半辞</span></a></h1></div><div class=description><p class=sub_title></p><div class=my_socials><a href=http://localhost:1313/index.xml type=application/rss+xml title=rss target=_blank><i class=ri-rss-fill></i></a></div></div></div></div><div class=content><div class=post_page><div class="post animate__animated animate__fadeInDown"><div class="post_title post_detail_title"><h2><a href=/posts/run-runloop-run/>Run, Run Loop, Run!</a></h2><span class=date>2016.09.09</span></div><div class="post_content markdown"><blockquote><p><em>翻译自 <a href=http://bou.io/RunRunLoopRun.html>http://bou.io/RunRunLoopRun.html</a></em></p></blockquote><p>尽管作为所有App最重要的组成部分之一，它仍是一个开发者很少被触及讨论的话题：Run Loop。Run Loop之于app的就像是跳动的心脏，他们是使你app运行的真正奥义。</p><p>事实上，一个run loop（运行循环）最基本的原则非常简单。在iOS和OS X<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>，<code>CFRunLoop</code>实现被更高层级发送和分发消息API使用的核心机制。</p><h1 id=所以run-loop到底是什么>所以，Run Loop到底是什么？</h1><p>简单的说，一个run loop是一个消息机制，用来异步或者线程间通信。可以被看作是一个等待信件的邮箱，并把他们分发到接受者。</p><p>一个run loop做两件事：</p><ul><li>等待事件发生（比如，消息到达）</li><li>把消息分发给它的接受者</li></ul><p>在别的平台上<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>，这种机制叫作Message Pump。</p><p>Run Loops是从命令行工具中分离出来的交互式应用程序。命令行工具通过带参数启动，执行命令，然后退出。交互式应用等待用户输入，作出响应，然后恢复等待。其实，这种基本的机制可以在久驻内存的进程中看到。运行于服务器的一个run loop就比如<code>while(1) { select(); }</code><sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>(#fn:3)。</p><p>Run loop的工作就是等待事件发生。这些事件可以是外部事件，由用户或者系统触发（比如网络请求）或者应用内消息（比如线程间通知、异步代码执行、timer计时器。一旦一个事件（或者叫“消息”）到达，run loop会寻找一个相关的监听器（listener）并传递事件。</p><p>一个基本的run loop实现起来非常简单。下面是一段伪代码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>func postMessage(runloop, message)
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>    runloop.queue.pushBack(message)
</span></span><span class=line><span class=cl>    runloop.signal()
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>func run(runloop)
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>    do {
</span></span><span class=line><span class=cl>        runloop.wait()
</span></span><span class=line><span class=cl>        message = runloop.queue.popFront()
</span></span><span class=line><span class=cl>        dispatch(message)
</span></span><span class=line><span class=cl>    } while(true)
</span></span><span class=line><span class=cl>}
</span></span></code></pre></div><p>通过这个简单的机制，每个线程都可以<code>run()</code>它们自己的run loop，并且和其他线程的run loop通过<code>postMessage()</code>异步地交互信息。我的同事<a href=http://www.opensource.apple.com/source/CF/CF-855.17/CFRunLoop.c>Cyril Mottier</a>指出<a href=https://github.com/android/platform_frameworks_base/blob/master/core/java/android/os/Looper.java#L110-L155>Android的实现</a>并不比这个复杂太多。</p><h1 id=那-ios-和-os-x-呢>那 iOS 和 OS X 呢</h1><p>在苹果的系统中，这是 <strong><code>CFRunLoop</code></strong> 的工作，以一种<a href=http://www.opensource.apple.com/source/CF/CF-855.17/CFRunLoop.c>稍微高级的变体</a><sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>的方式。<em>从某种程序上来说，你所写的代码都是被<code>CFRunLoop</code>调用的</em>，除了最开始的初始化，或者你自己创建线程。（就我所知，线程为Grand Central Dispatch自动创建，不需要<code>CFRunLoop</code>，但可以确定有一个消息系统来允许重用）。</p><p>CFRunLoop最重要的特性就是 <strong>CFRunLoopModes</strong>。CFRunLoop与Run Loop源（Run Loop Sources）交互工作。源在一个run loop上注册一个或者多个 <strong>模式（mode）</strong>，run loop会在给定的一个模式下运行。当一个源上的事件到达时，如果源模式符合run loop当前模式，它才会被这个run loop处理。</p><p>另外，在应用的代码中，<strong>CFRunLoop是可以被重入的</strong>，无论是你自己的代码还是框架中的代码。因为每个线程只有一个run loop，当一个组件想在一个特定的模式运行时，它只需调用 <code>CFRunLoopRunInMode()</code> 即可。此时没有被注册到这个模式的run loop源会被简单的执行停止操作。通常，那个组件最终会把控制权返回给之前的模式。</p><p>CFRunLoop定义了一个伪模式（pseudo-mode）叫作“common modes”（<code>kCFRunLoopCommonModes</code>），它实际上是一个应用中包含“正常”run loop模式的集合。最开始，主run loop会运行在<code>kCFRunLoopCommonModes</code>模式下。</p><p>另一方面，UIKit定义了一个叫作<code>UITrackingRunLoopMode</code>的特殊run loop模式。“当跟踪控件时”会使用这个模式，比如触摸事件。这很重要，因为它保证了tableview很顺滑的滚动。当主线程的run loop在<code>UITrackingRunLoopMode</code>模式下，比如网络请求回调等是不会被分发处理的。没有其他操作进行的方式保证滚动时不会卡顿。（好吧，至少现在那是你的错误观点<sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup>。）</p><h1 id=cfrunloop解迷>CFRunLoop解迷</h1><p>如果你已经在iOS或者OS X调试过调用栈，你可以已经注意到，在调用栈的底部，一个全大写的消息以 <code>CFRUNLOOP_IS_CALLING_OUT</code> 开头。当CFRunLoop调用应用代码时，就像是做一个关于它的表演。在CFRunLoop.c中一共定义了6种这种的函数：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-objc data-lang=objc><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>__CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>__CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__</span><span class=p>();</span>
</span></span></code></pre></div><p>正如你所猜测的，这些函数的主要作用就是帮助在调用栈里调试。CFRunLoop确保所有的应用代码都会被这些函数中的某一个调用。</p><p>我们一个一个的看。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-objc data-lang=objc><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>CFRunLoopObserverCallBack</span> <span class=n>func</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>CFRunLoopObserverRef</span> <span class=n>observer</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>CFRunLoopActivity</span> <span class=n>activity</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=o>*</span><span class=n>info</span><span class=p>);</span>
</span></span></code></pre></div><p><strong>观察者</strong>有点特殊。你可以通过<code>CFRunLoopObserver</code>API观察CFRunLoop的行为，并得到它的活动的通知：当它在处理事件时，当它准备休眠时等等。这在调试时会显得非常有用，你可能在你的应用中并不需要它，但如果你想了解CFRunLoop的特性时你就可以这样做。</p><blockquote><p>2014-10-02更新：<br>事实上，它们在特定情形下会很有用。比如，CoreAnimation从它的观察者处被调用。它是有意义的：通过确定所有的UI代码都已经执行，它会执行起所有的动画。</p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-objc data-lang=objc><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>__CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__</span><span class=p>(</span><span class=kt>void</span> <span class=p>(</span><span class=o>^</span><span class=n>block</span><span class=p>)(</span><span class=kt>void</span><span class=p>));</span>
</span></span></code></pre></div><p>Blocks就是<code>CFRunLoopPerformBlock()</code>API的中的block，你想在“下一次运行循环”时运行你的代码会用到这个。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-objc data-lang=objc><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>msg</span><span class=p>);</span> 
</span></span></code></pre></div><p>这个 <strong>主调度队列(Main Dispatch Queue)</strong> 当然是CFRunLoop在和GCD交互时使用的。显然，至少在主线程中GCD和CFRunLoop会协同工作。尽管CGD能并且也会建立没有CFRunLoop的线程，但当存在一个线程的时候，一个CFRunLoop也就存在了<sup id=fnref:6><a href=#fn:6 class=footnote-ref role=doc-noteref>6</a></sup>。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-objc data-lang=objc><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>__CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>CFRunLoopTimerCallBack</span> <span class=n>func</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>CFRunLoopTimerRef</span> <span class=n>timer</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=o>*</span><span class=n>info</span>
</span></span><span class=line><span class=cl><span class=p>);</span>
</span></span></code></pre></div><p>Timer顾名思义定时器。在iOS和OS X上，高级的定时器像NSTimer或者<code>performSelector:afterDelay:</code>是使用CFRunLoop定时器实现的。从iOS7和Mavericks开始，Timer对它的触发时间有一个_宽容度_，这个特性也是由CFRunLoop处理的。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-objc data-lang=objc><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>perform</span><span class=p>)(</span><span class=kt>void</span> <span class=o>*</span><span class=p>),</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=o>*</span><span class=n>info</span>
</span></span><span class=line><span class=cl><span class=p>);</span>
</span></span></code></pre></div><p><code>CFRunLoopSource</code> 的“Version 0”和“Version 1”实际上是非常不同的东西，尽管他们有着相同的API。<strong>Version 0源</strong>只是一个简单的应用内的消息机制，并且必须通过应用程序代码来手动处理。在通过<code>CFRunLoopSourceSignal()</code>发出一个Version 0源的信号后，CFRunLoop必须通过<code>CFRunLoopWakeUp()</code>被唤醒来为这个源处理事件。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-objc data-lang=objc><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=o>*</span><span class=p>(</span><span class=o>*</span><span class=n>perform</span><span class=p>)(</span><span class=kt>void</span> <span class=o>*</span><span class=n>msg</span><span class=p>,</span> <span class=n>CFIndex</span> <span class=n>size</span><span class=p>,</span> <span class=n>CFAllocatorRef</span> <span class=n>allocator</span><span class=p>,</span> <span class=kt>void</span> <span class=o>*</span><span class=n>info</span><span class=p>),</span>
</span></span><span class=line><span class=cl>    <span class=n>mach_msg_header_t</span> <span class=o>*</span><span class=n>msg</span><span class=p>,</span> <span class=n>CFIndex</span> <span class=n>size</span><span class=p>,</span> <span class=n>mach_msg_header_t</span> <span class=o>**</span><span class=n>reply</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>perform</span><span class=p>)(</span><span class=kt>void</span> <span class=o>*</span><span class=p>),</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=o>*</span><span class=n>info</span>
</span></span><span class=line><span class=cl><span class=p>);</span>
</span></span></code></pre></div><p>与之相对应，<strong>Version 1源</strong>使用<code>mach_ports</code>处理内核事件。这是CFRunLoop的核心。多数时候，当你的应用停留在那里什么也不做，它是被<code>mach_msg(...,MACH_RCV_MSG,...)</code>这个调用所阻塞。如果你通过Activity Monitor（中文名：活动监视器）从任何一个app进行取样，你可能会遇到这样的情形：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-objc data-lang=objc><span class=line><span class=cl><span class=mi>2718</span> <span class=n>CFRunLoopRunSpecific</span>  <span class=p>(</span><span class=k>in</span> <span class=n>CoreFoundation</span><span class=p>)</span> <span class=o>+</span> <span class=mi>296</span>  <span class=p>[</span><span class=mh>0x7fff98bb7cb8</span><span class=p>]</span>
</span></span><span class=line><span class=cl>  <span class=mi>2718</span> <span class=n>__CFRunLoopRun</span>  <span class=p>(</span><span class=k>in</span> <span class=n>CoreFoundation</span><span class=p>)</span> <span class=o>+</span> <span class=mi>1371</span>  <span class=p>[</span><span class=mh>0x7fff98bb845b</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=mi>2718</span> <span class=n>__CFRunLoopServiceMachPort</span>  <span class=p>(</span><span class=k>in</span> <span class=n>CoreFoundation</span><span class=p>)</span> <span class=o>+</span> <span class=mi>212</span>  <span class=p>[</span><span class=mh>0x7fff98bb8f94</span><span class=p>]</span>
</span></span><span class=line><span class=cl>      <span class=mi>2718</span> <span class=n>mach_msg</span>  <span class=p>(</span><span class=k>in</span> <span class=n>libsystem_kernel</span><span class=p>.</span><span class=n>dylib</span><span class=p>)</span> <span class=o>+</span> <span class=mi>55</span>  <span class=p>[</span><span class=mh>0x7fff99cf469f</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=mi>2718</span> <span class=n>mach_msg_trap</span>  <span class=p>(</span><span class=k>in</span> <span class=n>libsystem_kernel</span><span class=p>.</span><span class=n>dylib</span><span class=p>)</span> <span class=o>+</span> <span class=mi>10</span>  <span class=p>[</span><span class=mh>0x7fff99cf552e</span><span class=p>]</span>
</span></span></code></pre></div><p>它在CFRunLoop.c的<a href=https://github.com/opensource-apple/CF/blob/master/CFRunLoop.c#L2021>这个位置</a>。往上几行，可以看到来自苹果工程师从<a href=https://en.wikipedia.org/wiki/To_be,_or_not_to_be>哈姆雷特的独白</a>中引用的一段相关的话：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-objc data-lang=objc><span class=line><span class=cl><span class=cm>/* In that sleep of death what nightmares may come ... */</span>
</span></span></code></pre></div><h1 id=瞧一瞧cfrunloopc>瞧一瞧CFRunLoop.c</h1><p>无论何时你运行你的程序，CFRunLoop的核心是<code>__CFRunLoopRun()</code>这个函数，通过公有API<code>CFRunLoopRun()</code>和<code>CFRunLoopRunInMode(mode, seconds, returnAfterSourceHandled)</code>调用。</p><p>以下原因会使<code>__CFRunLoopRun()</code>退出：</p><ul><li><code>kCFRunLoopRunTimedOut</code>：超时的时候，如果指定了一个时间间隔；</li><li><code>kCFRunLoopRunFinished</code>：它变成“空”的时候，比如所有的源都被移除了；</li><li><code>kCFRunLoopRunHandledSource</code>：指定了<code>returnAfterSourceHandled</code>标志，在一个事件被分发完成的同时；</li><li><code>kCFRunLoopRunStopped</code>：通过手动调用<code>CFRunLoopStop()</code>使其停止时；</li></ul><p>在上面的任何一个原因出现之前，run loop都会持续等待并分发事件。下面看一下处理我们上面讨论过的各种事件类型的简单过程是什么样的：</p><ol><li>调用“blocks”，（通过<code>CFRunLoopPerformBlock()</code>API）</li><li>检查Version 0源，如果需要会调用它们的“执行”函数</li><li>轮询、内部调度队列和<code>mach_ports</code></li><li>如果没有可等待的事件则休眠。内核会在有事件发生的时候唤醒它。事实上代码里比这复杂得多，因为a)一个Win32兼容的代码会添加很多<code>#ifdef</code> <code>#elfi</code>条件编译选项并且b)代码中间有<code>goto</code>。主要的想法是<code>mach_msg()</code>可以被配置为等待多个队列和端口。CFRunLoop凭此可以同时等待所有的Timer，GCD调度，手动唤醒或者Version 1源。</li><li>唤醒，来看看为什么：<ol><li>手动唤醒。只是继续运行这个循环，可以是block或者Version 0源需要服务</li><li>一个或者多个Timer启动。调用它们的函数。</li><li>GCD需要工作。通过一个指定的“4CF”调度队列API来调用</li><li>一个Version 1源被内核发送。查找并服务它</li></ol></li><li>再次调用“blocks”</li><li>检查退出条件：Finished, Stopped, TimedOut, HandledSource</li><li>从头开始</li></ol><p>哟，很简单吧？你可能知道，CoreFoundation是由C实现的，坦率地说看起来并不是很现代。读完我的第一反应就是“哇，这个需要重构”。另一方面，这个代码不仅仅是场景测试，所以我也不指望后面会使用Swift的全部重写。</p><p>这是我这些年用的很多的一个代码模式，尤其是在测试里。它“一直运行直到这个条件变成真”，这是任何一种异步单元测试的基础。随着时间的推移，我可能与了很多它的变体，直接使用NSRunLoop或者CFRunLoop，做轮询，使用超时等等。现在我可以写一个它的像样的版本。我们下一篇文章里面再看～</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>我们需要一个苹果系统家族的名字。&ldquo;Darwin"不太对，因为它是底层系统的名字。OS？&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>在此之前，我写了很久的 Win32 代码。&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>如果你恰好不知道，可以<code>man 2 select</code>。&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p>CFRunLoop.c有3909行，而Looper.java只有309行。&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5><p>你可以还记得2011年的 <a href=https://plus.google.com/u/0/+AndrewMunn/posts/VDkV9XaJRGS>这篇文章</a> 把 iOS 上的滚动性能归功于“提升 UI 线程到一个实时的优先级”。后来被纠正，当然，那只是UITrackingRunLoopMode在完成它的工作。&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:6><p>说实话，我并不是很熟悉GCD的内部实现。我只是猜测它是如何工作的，如果错了请纠正我。&#160;<a href=#fnref:6 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><div class=post_footer></div></div><div class=doc_comments><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//davelliu.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></div></div></div><a id=back_to_top href=# class=back_to_top><i class=ri-arrow-up-s-line></i></a><footer class=footer><div class=powered_by><a href=https://varkai.com>Designed by VarKai,</a>
<a href=http://www.gohugo.io/>Proudly published with Hugo</a></div><div class=footer_slogan><span></span></div></footer><script src=http://localhost:1313/js/jquery-3.5.1.min.js></script>
<link href=http://localhost:1313/css/fancybox.min.css rel=stylesheet><script src=http://localhost:1313/js/fancybox.min.js></script>
<script src=http://localhost:1313/js/zozo.js></script>
<script type=text/javascript async src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML">MathJax.Hub.Config({tex2jax:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["[[","]]"]],processEscapes:!0,processEnvironments:!0,skipTags:["script","noscript","style","textarea","pre"],TeX:{equationNumbers:{autoNumber:"AMS"},extensions:["AMSmath.js","AMSsymbols.js"]}}}),MathJax.Hub.Queue(function(){var e,t=MathJax.Hub.getAllJax();for(e=0;e<t.length;e+=1)t[e].SourceElement().parentNode.className+=" has-jax"})</script><style>code.has-jax{font:inherit;font-size:100%;background:inherit;border:inherit;color:#515151}</style></body></html>